<?php  if (!defined('BASEPATH')) exit('No direct script access allowed');

/**
 *  MY_Model extends CI_Model and defines some functions 
 *  that are useful in all models.
 *
 *	@category Model
 *	@package micron.manassas.Models
 *	@copyright Micron
 *  @version 0.01
 *	@since 2012-08-08
 *	@author Erin Cook <ecook@micron.com>
 *  @location ./application/model/user_model.php
 */
class MY_Model  extends CI_Model
{
	
	//construct
	function __construct()
	{
		parent::__construct();
	}
	
	
	/**
	 * This function applies a filter defines by the programmer.  This allows for
	 *  dynamic creation of the filter and simplifies models by reducing duplicate
	 *  code.  This cuts down on duplicate code by allowing for a very generic
	 *  function.
	 *  This function should be applied directly before calling
	 *    $query = $this->db->get('tablename');
	 *
	 *  <strong>Examples</strong>
	 *	<strong>Simple example of input (only where joined by and)</strong>
	 *  <code>
	 *   $filter = array( 
	 *      'where' => array(
	 *   	    'field_name' => 'value', //produces: WHERE field_name = 'value' ....
	 *   	    'field_name' => array('value1', 'value2'), //produces: WHERE field_name IN ('value1', 'value2'),
	 *   	    'field_name <', 'value', //produces: WHERE field_name < 'value'
	 *      )
	 *   );
	 *  </code>
	 *
	 *	<strong>
	 *    Defining a custom where string - AVOID THIS USAGE. This will not clean the data.
	 *  </strong>
	 *  <code>
	 *   $filter = array(
	 *     'where' = array(
	 *       "name='Joe' AND status='boss' OR status='active'"
	 *     )
	 *   );
	 *  </code>
	 *
	 *  <strong>Complex example input for the $filter array. (where and likes)</strong>
	 *  <code>
	 *  $filter = array(
	 *    'where' => array(
	 *      //same pattern as simple shown in the simple example.
	 *    ),
	 *   'like' => array(
	 *      array(
	 *        'field' => 'field name',
	 *        'value' => 'the desired value',
	 *        //wildcard_position is optional - defaults to both
	 *        'wildcard_position' => string options: 'both', 'before', 'after' 
	 *        'negate' => boolean value //optional - defaults to false.
	 *  		),
	 *      //additional likes to apply
	 *    ),
	 *   'not_like' => array(
	 *      //same as like but doesn't process a negate value.
	 *  	),
	 *  	'or_like' => array(
	 *  		array(
	 *  			'field' => 'field name',
	 *  			'value' => 'the desired value',
	 *        //wildcard_position is optional - defaults to both
	 *        'wildcard_position' => string options: 'both', 'before', 'after' 
	 *        'negate' => boolean value //optional - defaults to false
	 *  		),
	 *  	  //aditional or likes
	 *  	),
	 *  	'or_not_like' => array(
	 *  		//same as or_like but doesn't process a negate value.
	 *    ),
	 *  );
	 *  </code>
	 *
	 *  @link http://codeigniter.com/user_guide/database/active_record.html#select 
	 *    Code Igniter's active record.
	 *
	 *  @usedby almost all models to apply a filter.
	 *
	 *  @param array $filter  an array of data containing the filter. See examples towards the bottom of
	 *   this comment block.
	 *  @param object $db  an object representing the database generated by CI.
	 *		This is passsed so that this function knows where to apply the filter to.
	 */
	protected function applyFilter($filter, &$db)
	{
		//if the filter is empty save us some time and not even try.
		if (count($filter) == 0) return;
		
		
		//apply the filter the wheres
		$where = array();
		if (isset($filter['where']))
		{
			$where = $filter['where'];
			
		}
		
		//sets wheres...
		foreach ($where as $index => $filterData)
		{
			if (is_array($filterData))
			{
				//loop through an apply each one.
				foreach($filterData as $field => $value)
				{
					$db->where($field, $value);
				}
			}
			else
			{	
				//allows for custom defination.  this should be avoided
				// because it doesn't clean the data then.
				if (is_string($index))
				{
					$db->where($index, $filterData);
				}
				else
				{
					$db->where($filterData);
				}
			}
		}

		$where_not = array();
		if (isset($filter['where_not']))
		{
			$where_not = $filter['where_not'];
		}
		foreach ($where_not as $index => $filterData)
		{
			if (is_array($filterData))
			{
				//loop through an apply each one.
				foreach($filterData as $field => $value)
				{
					$db->where($field . ' !=', $value);
				}
			}
			else
			{	
				//allows for custom defination.  this should be avoided
				// because it doesn't clean the data then.
				if (is_string($index))
				{
					$db->where($index . ' !=', $filterData);
				}
				else
				{
					throw new exception('where_not filter not applied as expectes');
				}
			}
		}

		
		$where_in = array();
		if (isset($filter['where_in']))
		{
			$where_in = $filter['where_in'];
		}
		foreach($where_in as $index => $filterData)
		{
			if (isset($filterData['field']) && isset($filterData['value']))
			{
				$escape = true;
				if (isset($filterData['escape'])) $escape = $filterData['escape'];
				$db->where_in($filterData['field'], $filterData['value'], $escape);
			}
			else
			{
				$db->where_in($index, $filterData);
			}
		}
		
		$where_not_in = array();
		if (isset($filter['where_not_in']))
		{
			$where_not_in = $filter['where_not_in'];
		}
		foreach ($where_not_in as $index => $filterData)
		{
			$db->where_not_in($index, $filterData);
		}
		
		$or_where_in = array();
		if (isset($filter['or_where_in']))
		{
			$or_where_in = $filter['or_where_in'];
		}
		foreach($or_where_in as $index => $filterData)
		{
			$db->or_where_in($index, $filterData);
		}
		
		//sets likes...
		$like = array();
		if (isset($filter['like']))
		{
			$like = $filter['like'];
		}

		foreach($like as $field => $likeData)
		{

			//set some default values...
			$wildcard = 'both';
			$negate = false;
			$doPosixRegex = false;
			//check to see if default values need to change
			if (isset($likeData['wildcard_position'])) $wildcard = $likeData['wildcard_position'];
			if (isset($likeData['not'])) $negate = $likeData['not'];
			if (isset($likeData['doPosixRegex'])) $doPosixRegex = $likeData['doPosixRegex'];
			if ($negate)
			{
				//apply not like
				$db->not_like($likeData['field'], $likeData['value'], $wildcard, $doPosixRegex);
			}
			else
			{
				//apply the like.
				$db->like($likeData['field'], $likeData['value'], $wildcard, $doPosixRegex);
			}
		}
		
		$or_like = array();
		if (isset($filter['or_like']))
		{
			$or_like = $filter['or_like'];
		}
		foreach ($or_like as $field => $likeData)
		{
			//set some default values...
			$wildcard = 'both';
			$negate = false;
			$doPosixRegex = false;
			//check to see if default values need to change
			if (isset($likeData['wildcard_position'])) $wildcard = $likeData['wildcard_position'];
			if (isset($likeData['not'])) $negate = $likeData['not'];
			if (isset($likeData['doPosixRegex'])) $doPosixRegex = $likeData['doPosixRegex'];
			
			if ($negate)
			{
				//apply not like
				$db->or_not_like($likeData['field'], $likeData['value'], $wildcard, $doPosixRegex);
			}
			else
			{
				//apply the like.
				$db->or_like($likeData['field'], $likeData['value'], $wildcard, $doPosixRegex);
			}
		}
		
		//or not like
		$or_not_like = array();
		if (isset($filter['or_not_like']))
		{
			$or_not_like = $filter['or_not_like'];
		}
		foreach ($or_not_like as $field => $likeData)
		{
			$wildcard = 'both';
			$doPosixRegex = false;
			if (isset($likeData['wildcard_position'])) $wildcard = $likeData['wildcard_position'];
			if (isset($likeData['doPosixRegex'])) $doPosixRegex = $likeData['doPosixRegex'];
			$db->or_not_like($likeData['field'], $likeData['value'], $wildcard, $doPosixRegex);
		}
		
		$not_like = array();
		if (isset($filter['not_like']))
		{
			$not_like = $filter['not_like'];
		}
		foreach ($not_like as $field => $likeData)
		{
			$wildcard = 'both';
			$doPosixRegex = false;
			if (isset($likeData['wildcard_position'])) $wildcard = $likeData['wildcard_position'];
			if (isset($likeData['doPosixRegex'])) $doPosixRegex = $likeData['doPosixRegex'];
			$db->not_like($likeData['field'], $likeData['value'], $wildcard, $doPosixRegex);
		}
		
	}
	
	
 
}